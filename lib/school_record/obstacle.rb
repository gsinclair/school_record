
module SchoolRecord
  # An obstacle is something that prevents a lesson from taking place, like an
  # excursion or a special assembly, or even an exam block.  Public holidays are
  # not counted as obstacles because they are not school days.
  #
  # Obstacle objects are generated by Obstacle.from_yaml(file), which looks
  # something like this:
  #
  #   Sem1:
  #     - date: 3 June
  #       classes: 7, 10
  #       reason: Moderator's assembly
  #     - date: 12B-Wed
  #       class: 7
  #       reason: Geography excursion
  #     - dates: ["9A-Mon", "9A-Thu"]
  #       class: 7
  #       reason: Exams
  #     - date: 3A-Mon
  #       class: 11(4)
  #       reason: Maths assembly
  #   Sem2:
  #     - ...
  #
  # Notice that a specific period can be specified, as in 11(4), to clarify an
  # obstacle that affects only one period of a double.
  #
  # Obstacle objects are dumb objects. They store information and do not check
  # the validity of it against the Timetable or the Calendar. The one piece of
  # smarts they do is determine whether this particular obstacle matches a given
  # schoolday and class label.
  class Obstacle
    def initialize(dates, lessons, reason)
      @dates, @lessons, @reason = dates, lessons, reason
    end
    private :initialize

    attr_reader :dates, :reason

    # An obstacle "matches" a given lesson only if the date is within this
    # obstacle's date range and the class label matches as well. If a specific
    # period applies to a class -- say the spec was "classes: 7, 11(4)" -- then
    # the period of the given lesson must match as well.
    def match?(schoolday, lesson)
#      sr_int "Obstacle#match? -- lesson argument incomplete" unless
#        lesson.fully_specified?
      obstacle_lessons = @lessons
      schoolday.date.in? @dates and
        obstacle_lessons.any? { |spec|
          spec.class_label == lesson.class_label and
            (spec.period.nil? or spec.period == lesson.period)
        }
    end

    def Obstacle.from_yaml(calendar, string)
      ObstacleCreator.new(calendar, string).obstacles
    end

    class ObstacleCreator
      # Implemented below.
    end

    def to_s
      x = %{
        | Obstacle: dates=#{@dates}
        |           lessons=#{@lessons}
        |           reason=#{@reason}
      }.margin
    end
  end  # class Obstacle
end  # module SchoolRecord


class SR::Obstacle::ObstacleCreator
  def initialize(calendar, string)
    @calendar, @string = calendar, string
  end

  # Returns an _array_ of Obstacle objects.
  def obstacles
    data = YAML.load(@string)
    error unless data.is_a? Hash and data.keys == ["Sem1", "Sem2"]
    # To assist in the coding, this is what we would get if we loaded the
    # sample shown above (just the "Sem1" part), courtesy of 'ap':
    #   "Sem1" => [
    #     [0] {
    #           "date" => "3 June",
    #        "classes" => "7, 10",
    #         "reason" => "Moderator's assembly"
    #     },
    #     [1] {
    #           "date" => "12B-Wed",
    #          "class" => 7,
    #         "reason" => "Geography excursion"
    #     },
    #     [2] {
    #          "dates" => [ "9A-Mon",  "9A-Thu" ],
    #          "class" => 7,
    #         "reason" => "Exams"
    #     },
    #     [3] {
    #           "date" => "3A-Mon",
    #          "class" => "11(4)",
    #         "reason" => "Maths assembly"
    #     }
    sem1 = data["Sem1"] || []
    sem2 = data["Sem2"] || []
    create_obstacles(sem1, 1) + create_obstacles(sem2, 2)
  end

  private
  def error(str)
    sr_err :obstacle_yaml, str
  end

  # Arguments: array of hashes, each containing info about an obstacle, and the
  # semester (1..2) in which these obstacles take place.
  def create_obstacles(array, semester)
    array.map { |hash| create_obstacle(hash, semester) }
  end

  # Examples of the hash argument (though keys are strings, not symbols):
  #   { date: "12B-Wed", class: 7, reason: "..." }
  #   { date: "6 June", classes: "7,10", reason: "..." }
  #   { dates: ["9A Mon", "9A Thu"], class: 11, reason: "Exams" }
  # This shows that:
  #  * date can be singular or plural, and is semester-sensitive
  #  * class can be singular or plural, and may be an integer instead of a string
  def create_obstacle(hash, semester)
    dates = hash.values_at("date", "dates").compact
    error unless dates.size == 1
    dates = dates.first.split(" --> ")
    error unless dates.all? { |d| d.class.in? [String, Date] }
    schooldays = dates.map { |d| schoolday(d, semester) }
    dates = (schooldays.first.date .. schooldays.last.date)

    lesson_spec = hash.values_at("class", "classes").compact
    error unless lesson_spec.size == 1
    lesson_spec = lesson_spec.first.to_s.split(/, */)
    lessons = lesson_spec.map { |str|
      class_label, period = parse_lesson_spec(str)
      SR::DO::Lesson.new(class_label, period)
    }

    reason = hash["reason"]
    error unless String === reason
    error if reason == ""

    SR::Obstacle.new(dates, lessons, reason).tap do |o|
      debug "Obstacle created:"
      debug o.to_s.indent(8)
    end
  end

  # Generates a SchoolDay object, as per Calendar#schoolday, but the string
  # "Sem1" or "Sem2" is appended so that a date string like "3A Fri" is
  # interpreted in the correct context.
  def schoolday(date_str, semester)
    ds = SR::DateString.new(date_str)
    date_str << " #{Date.today.year}" if ds.contains_only?(:month, :mday)
    date_str << " Sem#{semester}" if ds.contains_only?(:wday, :sem_week)
    @calendar.schoolday(date_str)
  end

  # Returns class_label and period. Period may be nil.
  #   "10"      -> [10,nil]
  #   "10(4)"   -> [10,4]
  # Error if class_label is nil.
  def parse_lesson_spec(str)
    class_label, period = str.split '('
    error(str) if class_label.nil?
    if period
      period = period[/\d+/].to_i
    end
    [class_label, period]
  end
end  # class SR::Obstacle::ObstacleCreator

