
module SchoolRecord
  # An obstacle is something that prevents a lesson from taking place, like an
  # excursion or a special assembly, or even an exam block.  Public holidays are
  # not counted as obstacles because they are not school days.
  #
  # Obstacle objects are generated by Obstacle.from_yaml(file), which looks
  # something like this:
  #
  #   Sem1:
  #     - date: 3 June
  #       classes: 7, 10
  #       reason: Moderator's assembly
  #     - date: 12B-Wed
  #       class: 7
  #       reason: Geography excursion
  #     - dates: ["9A-Mon", "9A-Thu"]
  #       class: 7
  #       reason: Exams
  #     - date: 3A-Mon
  #       class: 11(4)
  #       reason: Maths assembly
  #   Sem2:
  #     - ...
  #
  # Notice that a specific period can be specified, as in 11(4), to clarify an
  # obstacle that affects only one period of a double.
  #
  # Obstacle objects are dumb objects. They store information and do not check
  # the validity of it against the Timetable or the Calendar. The one piece of
  # smarts they do is determine whether this particular obstacle matches a given
  # schoolday and class label.
  class Obstacle
    def initialize(schooldays, class_labels, period, reason)
      @schooldays, @class_labels, @period, @reason =
        schooldays, class_labels, period, reason
    end
    private :initialize

    attr_reader :schooldays, :class_labels, :period, :reason

    # An obstacle "matches" a schoolday and class label if the schoolday is
    # within the obstacle's range and if the class label is one of the
    # obstacle's class labels.
    # What we do about the period information, if there is any, I'm not sure.
    def match?(schoolday, class_label)
      date_match?(schoolday) and class_label.in? @class_labels
    end

    def Obstacle.from_yaml(calendar, string)
      ObstacleCreator.new(calendar, string).obstacles
    end

    class ObstacleCreator
      # Implemented below.
    end

    private
    def date_match?(schoolday)
      case @schooldays.size
      when 1
        @schooldays.first == schoolday
      when 2
        @schooldays.first <= schoolday and schoolday <= @schooldays.last
      else
        sr_int "Obstacle #{self} should have 1 or 2 'schooldays'"
      end
    end
  end  # class Obstacle
end  # module SchoolRecord


class SR::Obstacle::ObstacleCreator
  def initialize(calendar, string)
    @calendar, @string = calendar, string
  end

  # Returns an _array_ of Obstacle objects.
  def obstacles
    data = YAML.load(@string)
    error unless data.is_a? Hash and data.keys == ["Sem1", "Sem2"]
    # To assist in the coding, this is what we would get if we loaded the
    # sample shown above (just the "Sem1" part), courtesy of 'ap':
    #   "Sem1" => [
    #     [0] {
    #           "date" => "3 June",
    #        "classes" => "7, 10",
    #         "reason" => "Moderator's assembly"
    #     },
    #     [1] {
    #           "date" => "12B-Wed",
    #          "class" => 7,
    #         "reason" => "Geography excursion"
    #     },
    #     [2] {
    #          "dates" => [ "9A-Mon",  "9A-Thu" ],
    #          "class" => 7,
    #         "reason" => "Exams"
    #     },
    #     [3] {
    #           "date" => "3A-Mon",
    #          "class" => "11(4)",
    #         "reason" => "Maths assembly"
    #     }
    sem1 = data["Sem1"] || []
    sem2 = data["Sem2"] || []
    create_obstacles(sem1, 1) + create_obstacles(sem2, 2)
  end

  private
  def error
    sr_err :obstacle_yaml
  end

  # Arguments: array of hashes, each containing info about an obstacle, and the
  # semester (1..2) in which these obstacles take place.
  def create_obstacles(array, semester)
    array.map { |hash| create_obstacle(hash, semester) }
  end

  # Examples of the hash argument (though keys are strings, not symbols):
  #   { date: "12B-Wed", class: 7, reason: "..." }
  #   { date: "6 June", classes: "7,10", reason: "..." }
  #   { dates: ["9A Mon", "9A Thu"], class: 11, reason: "Exams" }
  # This shows that:
  #  * date can be singular or plural, and is semester-sensitive
  #  * class can be singular or plural, and may be an integer instead of a string
  def create_obstacle(hash, semester)
    dates = Array(hash.values_at("date", "dates").compact).flatten
    error unless dates.size.in? (1..2)
    error unless dates.all? { |d| d.class.in? [String, Date] }
    schooldays = dates.map { |d| schoolday(d, semester) }

    class_labels = hash.values_at("class", "classes").compact
    error unless class_labels.size == 1
    class_labels = class_labels.first.to_s.split(/, */)

    period = hash["period"]
    error if period and not (Integer === period and period > 0)

    reason = hash["reason"]
    error unless String === reason
    error if reason == ""

    SR::Obstacle.new(schooldays, class_labels, period, reason)
  end

  # Generates a SchoolDay object, as per Calendar#schoolday, but the string
  # "Sem1" or "Sem2" is appended so that a date string like "3A Fri" is
  # interpreted in the correct context.
  def schoolday(date_str, semester)
    ds = SR::DateString.new(date_str)
    date_str << " #{Date.today.year}" if ds.contains_only?(:month, :mday)
    date_str << " Sem#{semester}" if ds.contains_only?(:wday, :sem_week)
    @calendar.schoolday(date_str)
  end
end  # class SR::Obstacle::ObstacleCreator

